## VLDPPipeline で使う Pedersen “ベクトル” コミットメントの中身

| 項目          | 説明                                                                                                                                                   | 理由・効果                                                               |
| ----------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------- |
| **コミットする値** | クライアント側乱数キー **$k_c = (k_{c,1}, …, k_{c,\ell})$** と補助ビット列（タイムスタンプやセッション ID）                                                                           | ・後でキーを公開するとき「途中で差し替えていない」ことを保証 <br>・ビット列をそのまま見せず隠蔽                  |
| **数式**      | 既知の独立ベース点対 $(G_i, H_i)\_{i=1..ℓ}$ を Baby-Jubjub 上に固定し、<br>乱数 $r$ を選んで<br>$\displaystyle C = \sum_{i=1}^{\ell} k_{c,i}\,G_i \;+\; r\,H_{\text{rand}}$ | ・成分ごとに $G_i$ を分けることで「ベクトル」を⼀括封印 <br>・$H_{\text{rand}}$ で情報理論的ハイディング |
| **公開タイミング** | ① コミット $C$ は *初回メッセージ* に含めサーバーへ提出<br>② 後のラウンドで $k_c$ と $r$ を開示                                                                                       | ・サーバーは $C$ を検証キーにして、以後の乱数関連手続を一貫してチェック                              |
| **使われる場面**  | 1. **乱数共有手順**：サーバー鍵 $k_s$ 署名前にクライアントが $k_c$ を固定<br>2. **NIZK 証明**：LDP 処理が $(k_c,k_s)$ 由来の乱数で行われたかを証明するとき、$C$ を回路内入力に使用                               | ・クライアントが後から有利な乱数にすり替える攻撃を阻止                                         |
| **メリット**    | - **完全秘匿**：$k_c$ を開示するまで誰にも見えない<br>- **改竄不能**：開示後に別の $k'_c$ を名乗れない<br>- **ホモモルフィズム**：複数ユーザ分を足し算しても整合が壊れず、バッチ検証が高速                                    | Pedersen ならではの３点セット（ハイディング・バインディング・加法性）で効率と安全性を両取り                  |
| **サイズ感**    | Jubjub ポイント 32 B ×1（$C$ 全体）<br> → 1 ユーザあたり公開コストは **32 B**                                                                                            | 低帯域で済み、証明メッセージの大半は zk-SNARK 部分                                      |

### フローで見る位置づけ

```
┌──────────┐
│Client TEE │───① 乱数キー k_c 生成
└──────────┘
      │
      ▼
┌───────────────┐
│Pedersen Commit │───② C = Σ k_c,i G_i + r H
└───────────────┘
      │  C
      ▼
(シャッフラー経由でサーバーへ)
      │
  …以後のラウンド…
      │  k_c, r を開示＋
      │  NIZK で “正当処理” 証明
      ▼
┌──────────┐
│   Server   │───検証：C ?= Σ k_c,i G_i + r H
└──────────┘
```

### まとめ

* **何を隠す？** クライアント固有の乱数キー。
* **なぜ隠す？** 乱数操作による統計汚染を防ぎつつ、まだ公開しない段階でバインディングを確立。
* **どう使う？** 後の NIZK 証明で「正しい乱数で LDP を実行した」ことを安全に示す土台。

これが VLDPPipeline における Pedersen コミットメントの具体像です。
