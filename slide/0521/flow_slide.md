---
marp: true
theme: default
mermaid: true
paginate: true
title: CMS資料
author: 村瀬
date: 2025-05-016
style: |
  /* スライド全体の背景色と文字色 */
  section {
    background-color: #f5f5f5;
    color:rgb(47, 15, 224);
  }
  
  /* Mermaid 図内の文字色や背景色を調整 */
  .mermaid {
    /* Mermaid 図自体のスタイルをここで調整可能 */
    color: #333333;
        # transform: scale(0.7);

  }

  .mermaid .node text,
  .mermaid .edgeLabel text {
    font-size: 14px;
  }

section.title h1,
section.title h3,
section.title h6 {
  color: white;
}
---
<!-- ---
marp: true
theme: default
paginate: true
headingDivider: 2
_class: lead
--- -->
# VLDPPipeline の要点

- **目的**：ローカル差分プライバシー (LDP) で露呈する *入力操作攻撃*・*出力操作攻撃* を暗号学的に防ぎつつ，ローカルモデル／シャッフルモデル両方で効率良く検証可能にする

- **結果**：クライアント実行 < 2 s，サーバ検証 5–7 ms/クライアントで完了する実装を報告。

--- 

# 3 章 Preliminaries — 構成要素

<!-- --- 
## システム全体フロー

1. **乱数シードの安全共有**  
2. **Trusted Enclave で生データ取得＋署名**  
3. **アン・トラスト領域で LDP 処理 & NIZK 生成**  
4. **シャッフラーが順序をランダム化**  
5. **サーバが NIZK を検証し，正当な出力だけ集計**  
6. **集計結果を公開**  
**用語補足**

* **PRF** は “鍵付きハッシュ” の一種で、入力にランダム性が見えない値を返す擬似乱数関数です ([Cryptography Stack Exchange][1])。
* **PRG** は PRF を繰り返し呼び出して長い擬似乱数列を作る仕組みです ([Cryptography Stack Exchange][1])。
* **Trusted Enclave（TEE）** は CPU 内の隔離領域で、外部 OS から隠したまま鍵と機密計算を守るハードウェア機構です ([ウィキペディア][2], [Microsoft Learn][3])。 -->




### コミットメント： 採用プリミティブ:  **Pedersen ベクトルコミットメント** 
* **用途**: クライアントは乱数鍵 $k_c$ を先にコミットしてから開示し、後からの値の差し替えを防ぎます。


### デジタル署名：採用プリミティブ: **Schnorr 署名**
* **用途**: Trusted Enclave が秘密鍵で入力 \(x\) || 時刻に署名して入力真正性を示す


### NIZK-PK (zk-SNARK)**採用プリミティブ**: **Groth16 zk-SNARK**
* **用途**: クライアントは「Pedersen＋署名＋LDP 処理の正当性」を約 200 B の証明で提出し、サーバは１回のペアリングで検証します。
* **特性と採用メリット**: 証明が小さく通信負荷が低い、検証はミリ秒級で高スループット；trusted setup を要しますがサーバを準信頼とする前提で許容するらしい


### 疑似乱数生成 (PRG from PRF)  
- PRF からビット列を連結して乱数列を得る標準的手法。\
  LDP ノイズやシャッフル順序を再現可能にする。
* **採用プリミティブ**: 鍵付き **BLAKE2s** を PRF として直接乱数列に展開します ([Cryptology ePrint Archive][4])。
* **簡単流れと数式**: クライアント鍵 $k_c$ とサーバ鍵 $k_s$ を XOR して共通鍵 $k$ を得て、ラウンド識別子 $s_j$ と結合し $\rho_{i,j}= \text{BLAKE2s}(k‖s_j)$ を計算します。
* **用途**: 生成した $\rho_{i,j}$ を LDP ノイズとメッセージのシャッフル順のタネに用います。
* **特性と採用メリット**: BLAKE2s は 128-bit 相当の安全性と高速実装が知られ、同じ関数で PRF とハッシュを兼用できコードが軽くなります ([tosc.iacr.org][5])。




---

## 他方式との比較

| 方式 | 入力操作攻撃 | 出力操作攻撃 | シャッフルモデル | 互換乱数化 | 交互回数 |
|------|--------------|--------------|-----------------|-----------|---------|
| **VLDPPipeline** | ✔（署名） | ✔（NIZK） | ✔ | 汎用 | **1** |
| Kato et al. ‘21 | ✖ | ✔ | ✖ | 𝑘-RR, OUE | 多 |
| Song et al. ‘23 | ✖ | ✔ | ✖ | 𝑘-RR, OUE | 多 |
| Cheu et al. ‘19 (攻撃例) | 攻撃可能 | 攻撃可能 | ✖ | 汎用 | n/a |

- LDP は少数の不正クライアントで統計を崩壊させ得ることが実証済み
- 既存の「検証付き LDP」は出力のみを対象にし，入力の真正性は未保証
- VLDPPipeline はそれらを同時に満たす初のスキーム
---

# 5 章 脅威モデル

### クライアント  
- プログラムは**完全に悪意的**＋相互に共謀可。  
- ただし Trusted Enclave 内部は改竄不能

### サーバ  
- **セミホーネスト**（正規手順は守るが推測は最大化）。  
- クライアント公開鍵の真偽を識別できる前提

### シャッフラー  
- **Honest-but-curious** な非協力第三者。実装は mixnet 等を想定
---
### セキュリティ目標  
1. **入力真正性**：署名で改竄を排除  
2. **正当処理証明**：NIZK でプロトコル逸脱を検出  
3. **プライバシー保護**：シャッフル＋LDP により (ε, δ)-DP を維持  


---
## プロトコルの図
- 任意の数(今回はn)のCLientと　Shuffler　Serverが一つずついる
- どうやら最初に乱数を生成してる
![alt text](image.png)

---

## 登場人物と役割

* **クライアント（Client）**

  * 信頼できる環境（Secure Enclave等）で「生データを取得→署名」
  * それを使って「差分プライバシー化＋証明生成」を行い、結果を送信

* **シャッフラー（Shuffler）**

  * クライアントから受け取ったデータをバラバラに並べ替え、匿名化してサーバーへ中継

* **サーバー（Server）**

  * 受け取った出力と証明をチェック
  * 問題なければ統計を集計・公開

---

## 処理の流れ（全６ステップ）

1. **乱数の生成 (0)**

   * クライアントとサーバーで安全に使うランダム値を協調生成

2. **データの署名 (1→2)**

   * 信頼環境で生データ x を秘密鍵でサイン → (x, σₓ)

3. **差分プライバシー化＋証明 (2)**

   * (x, σₓ) と乱数 ρ を使い、プライバシー化した値 ẋ とゼロ知識証明 π を作成

4. **送信 (3)**

   * (ẋ, π) をシャッフラーへ送る
   * ※ローカルモデルでは直接サーバーへ

5. **並べ替え (4→5)**

   * シャッフラーで n 件の (ẋ, π) をシャッフルしてサーバーに中継

6. **検証・集計 (5→6)**

   * サーバーが π の正当性を検証 → 問題なければ ẋ を受理
   * 最後に全件を集計して結果を公開


---

論文の実験は大きく **2 段階** に分かれています。


## 1. 実データを用いた「現実的ユースケース」評価

### データセット
| 目的       | データ                           | 前処理                          | LDPアルゴリズム                   | 目標統計           |
| -------- | ----------------------------- | ---------------------------- | --------------------------- | -------------- |
| 位置ヒストグラム | Microsoft GeoLife GPS (182 人) | 1 日5 件×5 日分のGPSを郵便番号8 区分に集約  | 𝑘-ary RR (𝑘 = 8)          | 各日・各郵便番号の人数分布  |
| 電力平均値    | London Smart-Meter (5,567 世帯) | 直近5 日分の家庭平均を最大値6.928 kWhで正規化 | Real-valued LDP (精度𝑘 = 10) | 各日の平均電力消費      |
---
### 評価対象

同論文が提案する 3 スキーム

* **Base**　…毎タイムステップごとに乱数生成
* **Expand** …乱数を拡張して共有、通信量を削減
* **Shuffle** …シャッフルモデル対応・最小通信量

### 指標

* クライアント／サーバーそれぞれの計算時間
* 送受信バイト数
* zk-SNARK（Groth16）の証明サイズ・検証鍵サイズ・制約数&#x20;

### 結果（T = 5 日、中央値）

* **クライアント時間**

  * Randomize: 0.61–1.80 s（GPS）/ 0.62–1.82 s（電力）
* **サーバー検証時間** 2.5–4.4 ms/レコード
* **通信量（クライアント→サーバー）**

  * Base: 2,125 B
  * Expand: 1,864 B
  * Shuffle: **1,064 B** と最小&#x20;
* **証明鍵サイズ** 最大でも53 MB（Shuffle）で、セットアップ時に配布可能&#x20;

---

## 2. 合成データによるスケーラビリティ評価

パラメータを人工的に拡大し、性能曲線を取得。

| 変更点                         | 観測結果                                                      |              |                                                           |
| --------------------------- | --------------------------------------------------------- | ------------ | --------------------------------------------------------- |
| 乱数長                         | ρ                                                         | 32 B→1,024 B | 乱数長に比例して制約数・計算時間がほぼ線形増。Shuffle でも 1,024 B で ≈8 s と実用範囲内。  |
| Merkle 木深さ d\_MT (Expand 用) | d\_MT を 4→10 に増やすと GenRand は指数増だが、Randomize は約 2 s で頭打ち。  |              |                                                           |


<!-- 

### まとめ

* **現実データ実験**で「1 レコードあたりクライアント < 2 s／サーバー ≈ 5 ms」の高効率を確認。
* **Shuffle スキーム**は通信量を最少化しつつシャッフルモデルのプライバシ強化を達成。
* **スケーラビリティ実験**でランダムネスやタイムステップを大幅に増やしても線形～準線形で伸びることを確認。

つまり論文は、提案手法が **実デプロイ可能な速度・通信コスト** で動作し、パラメータを拡大しても破綻しないことを一連の実験で示しています。 -->
