**Abstract（要旨）**
ローカル差分プライバシー（LDP）は、クライアントの機密データを保護しながら、集計サーバーを信用することなく集約統計量を効率的に公開する手法です。シャッフルモデルは、LDPにもう一段のプライバシー層を加え、クライアントと集約器との対応を切り離します。しかしながら、LDPは悪意あるクライアントによる入力操作攻撃および出力操作攻撃に対して脆弱であり、集計結果を歪める可能性があります。
本研究では、初期の生データが認証済みであるというごく現実的な仮定のもと、悪意あるクライアントによる攻撃を防ぐ方法を示します。具体例として、この仮定が妥当な実世界のユースケースを挙げます。提案する検証可能なLDP（VLDP）スキームは、既存手法【37, 43】と異なりクライアントとサーバーの1回の対話のみで入力・出力操作攻撃の両方を防ぎます。さらに、本論文が初めてとなる、シャッフルモデルにおける効率的なVLDPスキームも提供します。局所モデル向けに2つのスキーム、シャッフルモデル向けに1つのスキームを定義・安全性証明し、クライアント実行時間を2秒未満、サーバー側処理をクライアントあたり5～7ミリ秒以下に抑えた実用性を示しました .

---

**1 Introduction（はじめに）**
多くの分散データ共有アプリケーションは、「ソースから得られるデータは正しく取得されたものか、あるいは任意に改ざんされたものか」のどちらかとみなします。しかし実際には、測定機器から中央サーバーへ送られるまでのパイプラインには複数の段階があり、攻撃者がその一部を制御している場合でも他が安全であれば、生データの真正性を検証できる余地があります。本研究の対象は、こうした状況下で中央サーバーが生データから正しくフォーマットされた入力のみを受け取ることを保証しつつ、差分プライバシーを適用してデータを集約・公開する問題です。特に、分散ノードがサーバーを信用せずにノイズを付加してから送信するローカルモデルおよび、その出力をさらにシャッフルしてプライバシー増幅を図るシャッフルモデルに着目します .

**ユースケース**

* **センサーネットワーク**
  センサーデバイスは複数のハードウェアセンサー（例：チップ）を備え、そのメインプログラムがどのセンサーを読み取るかとフォーマットを決定します。攻撃者はこのプログラムを差し替え、データ処理パイプラインを改ざん可能ですが、物理センサー自体や生データの生成には介入できません。
* **スマートメーター**
  複数家庭の電力消費を定期的に取得し集計すると、就寝パターンなどのプライバシー情報が漏洩しかねません。スマートメーター本体の改造は非コスト効率なので、外部アプリでLDPを適用できますが、このアプリは信頼できない環境にあるため、任意のデータを送信して統計を歪める可能性があります。
* **GPSを用いた群衆推定**
  スマートフォンやウェアラブルはGPSで位置情報を取得しますが、正確な座標は不要で粗い分布さえ分かれば十分です。ここでもLDPを用いて位置ヒストグラムを公開できます。しかし攻撃者が任意の座標を送れば分布が歪みます。OSレベルで取得された生のGPS座標は正しいとみなせても、ユーザースペースのアプリが送信する情報は改ざん可能です。さらに、スマートフォンの加速度センサーやスマートホームの温度センサーなど、さまざまなケースが同様の構造を持ちます。こうした生データを安全なコンポーネント（例：セキュアエンクレーブ、OSカーネル、ハードウェアモジュール）が処理し、その後のアプリケーションを検証可能にすることで、フォーマット済み入力の真正性を保証できると仮定します .

以上の背景から、本論文では「生データは信頼できる環境から署名付きで取得される」という最小限の仮定のもと、LDP機構に対する入力操作攻撃・出力操作攻撃を防ぐ検証可能なスキームを構築します。次節以降で関連研究を概観し、我々の設計と安全性証明を示します。
**2 関連研究**
本研究の範囲に合わせ、ここでは検証可能差分プライバシー（verifiable differential privacy: verifiable DP）プロトコルに限定して議論する。特に、シャッフルモデルにおける検証可能DP構成は学術文献上に存在しないと認識している .

**ローカルモデル**

* Ambainisら\[3]による暗号化𝑘-RR（k-ary randomized response）が最初期の取り組みである。Kikuchiら\[38]は投票用途向けにRRを再定義し、改ざん防止の暗号的構成を提案したが、Ambainisらはクライアント（回答者）が自身の真の入力に対応するランダム化結果を知らないことを重視し、オブリビアス・トランスファーやPedersenコミットメント、ゼロ知識証明を用いたプロトコルを提案した。コミットメントパラメータが確率に対応する有理数である必要から、高精度化すると通信コストが増大し、さらにシャッフルモデルへの拡張は明確に示されていない .
* Katoら\[37]はこれを𝑘-RR、Unary Encoding（OUE）、Local Hashing（OLH）へ拡張したが、同様に出力操作攻撃のみを想定し、入力操作攻撃への対策はない。本研究ではデジタル署名により入力の真正性を保証する点が異なる .
* Songら\[51]はクライアントがコミットした確率ベクトルの一部をサーバーが開示させることで正当性を検証する手法を示し、𝑘-RRとOUE向けに実装例を提示したものの、高精度化時の通信コストが依然として課題であり、他のランダマイザへの効率的な拡張方法は未提示である .
* さらに、匿名クレデンシャルからバイナリ属性を抽出するLDPと検証可能コンピューティングを組み合わせた研究\[44]もあるが、𝑘-RRやシャッフルモデルへの対応、および厳密なセキュリティ定義による検証は行われていない .
* 最も近い研究として、ブロックチェーン取引における属性公開にDPを適用しつつ匿名性を維持する手法\[43]がある。バイナリRRを用い、登録機関の署名による入力真正性担保、乱数の公平性検証、NIZK証明による正当性検証を行うが、非バイナリ属性への拡張は示されず、ブロックチェーン基盤によるレイテンシ・スケーラビリティの問題を抱える。本研究は汎用LDPランダマイザ対応、入力操作攻撃耐性、シャッフルモデルでの検証を実現し、クライアントとサーバーの1ラウンド対話で動作する点で差異がある .

**セントラルモデル**

* 集中モデル（Central Model）における検証可能DP研究としては、Ari Biswas & Graham Cormode\[45]などがある。彼らは悪意あるアナリストによる不正な結果公開を脅威モデルとし、単一キュレータおよびマルチパーティ設定でのDPトレーニング検証を扱うが、入力検証は範囲チェックに限定され、個々の値の厳密な検証は行われない .
* Bellら\[9]はプライベート確率的メカニズムの検証を扱うが、加法的ノイズによる集計クエリに限定され、汎用LDPランダマイザの検証まではカバーしていない。本研究の技術はこれらへの拡張にも資すると考えられる .

**その他の研究**

* ADSNARK\[7]は認証付きデータ上の計算証明を扱うが、分散設定やDP入力は考慮していない。
* LDPが入力操作攻撃（データポイズニング）に脆弱であることを指摘する研究群\[19,21,39,58]は、本研究のような暗号的手法の必要性を強調している .
**3 Preliminaries（事前知識）**

本節では、本論文で用いる暗号的手法の概要を示す。特に、非対話型ゼロ知識証明（NIZK）と、その構成要素となる疑似乱数関数、コミットメント、電子署名などについて定義する。

---

### 3.1 Zero-Knowledge Proofs（ゼロ知識証明）

本研究では、NP言語の関係 R に対して、証明者が秘密の証人 w を用い、公開文 x が (x, w) ∈ R であることを示す非対話型ゼロ知識証明（NIZK）を CRS（共通参照文字列）モデルで用いる。NIZK は以下の 4 つの確率多項式時間アルゴリズムからなる :

* **Setup(1^λ) → (ek, vk, trap):** 安全パラメータ λ を入力に、評価用鍵 ek、検証用鍵 vk、およびシミュレーション用トラップドア trap（〈シミュレータ〉用）を出力。
* **Prove(ek, x, w) → π:** 評価鍵 ek を用い、公開文 x と証人 w に対する証明 π を生成。
* **Verify(vk, x, π) → {⊤,⊥}:** 検証鍵 vk を用い、(x, π) が正当か判定。
* **Sim(vk, x) → π̂:** トラップドアを用いずに、公開文 x のみに基づく偽の証明 π̂ を生成（ゼロ知識性担保のため）。

これらにより、正当性の検証を行いながら、証人情報 w の漏洩を防止できる。

---

### 3.2 Cryptographic Primitives（暗号原語）

以下、本論文の各スキームで利用する基本的な暗号的構成要素を定義する。

1. **Pseudo-Random Functions (PRF)（疑似乱数関数）**

   * 鍵空間 K, 入力空間 X, 出力空間 Y に対し、関数族 { PRF\_k: X→Y } は、ランダム鍵 k を固定すると真の乱数関数と区別困難。
   * PRF から PRG（疑似乱数生成器）を構成するには、固定入力 x₁,…,x\_ℓ を用い、PRG(k)=PRF(k,x₁)∥…∥PRF(k,x\_ℓ) とすれば、長さ ℓ の乱数ビット列が得られる .

2. **Commitment Schemes（コミットメント）**

   * 𝐶(x,r) でコミットメント cm を作成。x は開示値、r はランダムネス。
   * **Binding（束縛性）**: ある cm から異なる (x′,r′) を見つけることは計算的に困難。
   * **Hiding（隠蔽性）**: cm のみから元の x を特定することは困難。 .

3. **Digital Signature Schemes（電子署名）**

   * (KeyGen, Sign, Verify) の三つ組で構成。
   * **EUF-CMA**（Chosen-Message 攻撃下での偽造耐性）を満たす必要がある。
   * Sign(sk, m) で署名 σ を生成し、Verify(pk, m, σ) で検証可能。 .

以上の暗号原語を組み合わせることで、Section 4 以降で述べる VLDP（Verifiable Local Differential Privacy）スキームの構成要素を実現していく。

**5 ローカルモデルおよびシャッフルモデルにおける検証可能な差分プライバシ**&#x20;
最初に，脅威モデルを説明する．次に，システムモデルを概説し，ローカルモデルとシャッフルモデルの両方に適用可能なVLDPスキームの形式的定義を与える．最後に，形式的なセキュリティ定義を提示する．

---

### 5.1 脅威モデル

シャッフルモデルには，クライアント，シャッフラー，サーバーの３種類のアクターが存在する（ローカルモデルではシャッフラーは除去される）．以下，各アクターごとに脅威モデルを記述する ．

#### 5.1.1 クライアント

* すべてのクライアントプログラムは悪意を持つ可能性があり，他のクライアントと共謀し得る．従って，スキームから任意に逸脱したり，偽の入力データを用いる可能性がある．
* ただし，クライアントプログラムは信頼実行環境を制御できず，署名付きの入力データ x 及びその署名 σₓ=Sig.Signₛₖᵢ(x‖tₓ) を取得するのみである．各クライアント i の信頼実行環境は秘密鍵 skᵢ を保持し，プログラムからアクセスできないと仮定する ．

#### 5.1.2 サーバー

* サーバーは半正直（semi-honest）であり，スキームに従いつつ最大限の情報を得ようと試みるが，不正な振る舞いは行わない．
* サーバーは他のアクターと共謀せず，PKIやホワイトリストにより信頼できる公開鍵 pkᵢ を検証できると仮定する ．

#### 5.1.3 シャッフラー

* シャッフラーは正直だが好奇的（honest-but-curious）で，独立かつ非共謀の第三者と仮定する．
* 実装にはミックスネット等の手法が存在するが，本研究では実装を問わず機能するスキーム構築を目的とし，詳細は付録Bに譲る ．

---

### 5.2 システムモデル

VLDP\Pipelineは，1台のサーバーと n クライアントが T タイムステップにわたりメッセージを送信する高レベルな処理パイプラインを表す．図3に示すように，

1. **GenRand**: クライアントとサーバー間の前処理で真の乱数を共同生成し，後続のランダマイズに用いる．
2. **Randomize**: 信頼実行環境が署名した生の入力値 x を取り込み，LDP出力 ẋ とNIZK証明 π を生成．
3. **Verify**: サーバーが ẋ, π を検証し，正当と判断した値のみ集計関数 f に供する．

シャッフルモデルでは，ステップ2で得た (ẋ, π) のペアをシャッフラーがランダム順に並べ替えてサーバーに渡すことで，送信元の識別を難しくする ．

---

### 5.3 形式的セキュリティ定義

VLDPスキームは，以下の性質を満たすべきである:

1. **完全性 (Completeness)**: 正直なクライアントの出力は必ずサーバーに受理される．
2. **整合性 (Soundness)**: 悪意あるクライアントが不正な出力をサーバーに受理させる確率はネグリジブル．
3. **ゼロ知識性 (Zero‐knowledge)**: サーバーが学ぶのはLDP出力 ẋ から得られる情報のみで，元の入力 x については何も学ばない．
4. **シャッフル識別不能性 (Shuffle Indistinguishability)**: シャッフルモデルにおいて，サーバーは異なるクライアント由来の出力を識別できない．

これらの形式的定義とそれに基づく実験的モデルは付録C.1で詳述する 。
**6 VLDP向け構築手法**&#x20;
本節では，3つのVLDPスキームを提案し，それぞれがVLDPパイプラインを構成する要素について説明する．各スキームは前のものを改善しており，最終的にシャッフルモデルに適用可能な効率的なVLDPスキームを得る．付録C.2には形式的なセキュリティ解析を収めている．

1. **Baseスキーム**

   * ローカルモデルにおける検証可能LDPを実現する．
   * GenRandプロトコルは，既存手法\[43]のVerRRアルゴリズムに着想を得たもので，各タイムインターバル（およびクライアント）ごとに一度実行する必要がある．
   * その他のアルゴリズムは新規構成であり，Baseスキームでは認証済みデータに対する入力操作攻撃への耐性，汎用的なLDPアルゴリズムのサポート，およびブロックチェーンを不要とする点で，\[43]と異なる保証を提供する．

2. **Expandスキーム**

   * Baseと同等のセキュリティ保証を維持しつつ，クライアントがGenRandの出力 `outᵢᶜ` をすべてのタイムインターバルで再利用できるようにする．
   * これによりサーバー側の計算負荷および通信量を大幅に削減し，DPの逐次合成（sequential composition）に適したスキームとなる．

3. **Shuffleスキーム**

   * Expandと同等の通信効率を持ちながら，さらにシャッフルモデルにおけるVLDPも達成する．

---

#### 6.1 Baseスキーム

図4は，1サーバー・𝑛クライアント環境におけるBaseスキームの詳細を示す．
各クライアント 𝑖 は，タイムインターバル 𝑗 に対応する新鮮な乱数 ρᵢ,ⱼ を得るため，サーバーとともに **GenRand₍base₎** プロトコルを実行する．乱数ρのビット長は，後続のLDPアルゴリズムで必要とされる長さℓに応じて，PRF出力の長さ |ρ| と比較して次のように扱う：

* ℓ≤|ρ| の場合は未使用ビットを単に無視
* ℓ>|ρ| の場合は追加のPRF入力を用いて必要なビット長を得る（本稿では説明簡潔化のため ℓ≤|ρ| と仮定）

実際の **GenRand₍base₎** の流れ：

1. クライアント 𝑖 は内部でPRFを用い，自身だけが知る乱数ビット列 ρᵢ,ⱼᶜ を生成
2. 𝑖 はコミットメント scheme を用い，ρᵢ,ⱼᶜ に対するコミットメント cmᵢ,ⱼ^ρᶜ を計算
3. cmᵢ,ⱼ^ρᶜ，クライアントの公開鍵 pkᵢ，タイムインターバルマーカー tⱼ をサーバーに送信
4. サーバーは同時に自身の乱数を生成し，署名付きで返却
5. この署名付き乱数とクライアントコミットメントを組み合わせることで，真のランダム値 ρᵢ,ⱼ が形成される

この設計により，クライアントがあらかじめ大量の乱数を生成し「あとから好きなものを選ぶ」ような振る舞いを防ぎ，**検証可能なランダマイズ**の要件を満たすことができる .

図4（Baseスキームのアルゴリズム概要）:

```text
Setup₍base₎(1^λ) → pp
KeyGen₍base₎(pp) → (ek, vk, pk_s, sk_s, L)
GenRand₍base₎(pp, aux) ↔ outᵢᶜ
Randomize₍base₎(pp, ek, tⱼ, outᵢᶜ, x, tₓ, σₓ) → (ẋ, π, τₓ)
Verify₍base₎(pp, vk, tⱼ, ẋ, π, τₓ) → ẋ ∪ ⊥
```

各アルゴリズムの詳しい定義は，図4内の疑似コードをご参照ください .

**6.2 Randomness Expansion（Expand）スキーム**
Baseスキームでは、各クライアントは各タイムインターバルごとに**GenRand**を都度実行する必要があり、クライアント数が増えると実用性に欠ける。Expandスキーム（図5）は、Merkle木を用いて𝑇個の乱数コミットメントを一度のGenRandでまとめて行うことで、各クライアントあたりGenRand実行回数を1回に削減する 。

* **GenRand\_expand（クライアント側）**

  1. ランダム鍵 𝑘ᵢᶜ を生成し、PRF(𝑘ᵢᶜ,1)…PRF(𝑘ᵢᶜ,𝑇) により乱数列 ®𝜌ᵢᶜ を得る
  2. 各 𝜌ᵢ,ⱼᶜ ごとにコミットメント cmᵢ,ⱼᶜ = Comm(𝜌ᵢ,ⱼᶜ; rᵢ,ⱼᶜ) を計算し、Merkle木の根 rtᵢ を構築
  3. (pkᵢ, rtᵢ) をサーバーに送信し、(𝑘ᵢˢ, σᵢˢ) を受信・検証
  4. 出力 outᵢᶜ = (®𝜌ᵢᶜ, ®rᵢᶜ, ®cmᵢᶜ, rtᵢ, 𝑘ᵢˢ, σᵢˢ) を保存

* **GenRand\_expand（サーバー側）**

  1. クライアントから (pkᵢ, rtᵢ) を受信
  2. 一意性チェック後、乱数シード 𝑘ᵢˢ を生成し署名 σᵢˢ = Sig.Signₛₖˢ(pkᵢ∥rtᵢ∥𝑘ᵢˢ)
  3. (𝑘ᵢˢ, σᵢˢ) を返送

* **Randomize\_expand**

  1. サーバーシード部分 ρᵢ,ⱼˢ = PRF(𝑘ᵢˢ∥sⱼ) を生成
  2. 真の乱数 ρᵢ,ⱼ = ρᵢ,ⱼᶜ ⊕ ρᵢ,ⱼˢ を計算
  3. LDP.Apply を用いて差分プライバシ化 ẋᵢ,ⱼ = LDP.Apply(xᵢ,ⱼ; ρᵢ,ⱼ) を得る
  4. NIZK-PK 証明 πᵢ,ⱼ では、「𝑗番目の乱数がMerkle木にコミットされた値であること」を追加で検証
  5. (ẋᵢ,ⱼ, πᵢ,ⱼ, τᵢ,ⱼ) をサーバーに送信し、Verify\_expand で検証後 ẋᵢ,ⱼ を受理

この設計により、クライアントあたり一度のGenRandで𝑇ステップ分の乱数を準備でき、通信量・サーバー側計算量は𝑇に依存しない 。

---

**6.3 シャッフルモデルスキーム（Shuffle）**
シャッフルモデルでは、各タイムインターバル𝑗でサーバーが「識別不能な順序で並べ替えられた」𝑛件の差分プライバシ値を受け取る。Shuffleスキーム（図6）は、Expandと同様のMer­­kle木なし／リソース効率を維持しつつ、シャッフル不可逆性を保証する検証可能DPを実現する 。

* **GenRand\_shuffle／KeyGen\_shuffle** は概ねExpandと同じだが、CRSとしてシャッフル用の公開パラメータを含む

* **Randomize\_shuffle**

  1. クライアントシード 𝑘ᵢ = 𝑘ᵢᶜ ⊕ 𝑘ᵢˢ を構成し、ρᵢ,ⱼ = PRF(𝑘ᵢ, sⱼ) を計算
  2. ẋᵢ,ⱼ = LDP.Apply(xᵢ,ⱼ; ρᵢ,ⱼ) を得る
  3. 証明者知識 wᵢ,ⱼ に基づき、NIZK-PK 証明 πᵢ,ⱼ を生成（入力真正性と乱数生成正当性を同時に検証）
  4. (ẋᵢ,ⱼ, πᵢ,ⱼ) をシャッフラーに送信

* **シャッフラー** は受信した全メッセージをランダム順に並べ替えてサーバーに中継

* **Verify\_shuffle**

  1. 各ペア(ẋᵢ,ⱼ, πᵢ,ⱼ)に対しNIZK-PK.Verifyを実行し、正当なもののみ集計に使用

この構成により、サーバーは送信元の識別ができず、かつ不正に改ざんされた入力や乱数を受理しない検証可能なシャッフルモデルDPを達成する 。

---

次節では、これら3方式の**実験評価**（クライアント／サーバーの計算コスト・通信量・NIZK-PK制約数など）を、日本語で解説します。
**7 実験評価**
提案手法の実用性と性能を評価するため，合成データおよび実データを用いた一連の実験を行った．通信コストや計算時間を測定し，各スキームの比較を行う．

**7.1 実装**
すべてのスキームは Rust 言語で実装し，Arkworks v0.4 ライブラリを用いて zk-SNARK や暗号原語を実装した．セキュリティレベルは 128 ビットを目標とし，以下のように構成要素を選定している :

* **NIZK-PK**: Groth16 zk-SNARK（BLS12-381 曲線）を用い，定数サイズの証明を生成。
* **署名**: Jubjub 曲線上の EC-Schnorr 署名を採用し，証明回路内での効率的検証を実現。
* **コミットメント**: Jubjub 上の Pedersen ベクトルコミットメント（4 ビット窓）を用い，情報論的隠蔽性と計算的束縛性を両立。
* **PRF**: keyed Blake2s-256 により 256 ビット出力を得る疑似乱数関数を構築。
* **Merkle 木**（Expand スキームのみ）: 葉に Pedersen コミットメントを用い，上位ノードのハッシュには Pedersen ハッシュを利用 。

**7.2 実験設定**

* **データセット**:

  * Geolife GPS Trajectory（182 ユーザー，1日あたり最大 8 ポストコードのヒストグラム）
  * Smart meter（5,567 世帯，精度 𝑘=10 の実数値データ）
    いずれも前処理後に 𝑇=5 日分を用いた .
* **測定項目**: 各アルゴリズム（GenRand-1, GenRand-2, Randomize, Verify）のクライアント／サーバー計算時間（中央値，100ラン×3ウォームアップ除去），および通信メッセージサイズ。
* **環境**: Windows 10 デスクトップ（Ryzen 3600, 6c/12t\@4.0 GHz, 16 GB DDR4）＋Rust 1.77.2 。

**7.3 実データによる評価**

* **ランダムネス量:**
  * Geolife: \|𝜌\| = 16 bytes
  * Smart meter: \|𝜌\| = 24 bytes

**Table 1: 単一実行あたりの計算時間・通信量・証明鍵サイズ・制約数  
(Geolife／Smart meter, Base／Expand／Shuffle)**

| データセット／スキーム     | クライアント<br>GenRand-1 (ms) | GenRand-2 (ms) | Randomize (s) | サーバー<br>GenRand (ms) | Verify (ms) | 送信 (bytes)                | 受信 (bytes)    | \|ek\|   | \|vk\| | 制約数    |
|:--------------------------|-------------------------------:|---------------:|--------------:|-------------------------:|-----------:|-----------------------------|-----------------|---------:|-------:|----------:|
| **Geolife Base**         |                          0.218 |          0.302 |         0.610 |                    2.494 |      3.454 | 65 × 5 + 360 × 5 = 2,125    | 96 × 5 = 480    | 16.1 MB  | 776 B |   55,884 |
| **Geolife Expand**       |                          3.033 |          0.267 |         1.213 |                    2.005 |      4.425 | 64 + 360 × 5 = 1,864        | 96              | 23.4 MB  | 824 B |   74,322 |
| **Geolife Shuffle**      |                          0.230 |          0.305 |         1.798 |                    2.413 |      2.680 | 64 + 200 × 5 = 1,064        | 96              | 53.2 MB  | 728 B |  173,460 |
| **Smart meter Base**     |                          0.223 |          0.213 |         0.619 |                    2.146 |      3.484 | (Geolife Baseと同上)        | (同上)          | 16.3 MB  | 776 B |   56,903 |
| **Smart meter Expand**   |                          2.475 |          0.211 |         1.106 |                    1.271 |      3.540 | (Geolife Expandと同上)      | (同上)          | 23.7 MB  | 824 B |   75,341 |
| **Smart meter Shuffle**  |                          0.225 |          0.293 |         1.821 |                    2.119 |      2.659 | (Geolife Shuffleと同上)     | (同上)          | 53.3 MB  | 728 B |  174,095 |


* **Table 2**: 全ステップ（𝑇=5）合計の計算時間を示す 。

| データセット / スキーム           | クライアント<BR>Total GenRand-1 (ms) | 同 GenRand-2 (ms) | 同 Randomize (s) | サーバー<BR>Total GenRand (s) | 同 Verify (s) |
| :---------------------- | -----------------------------: | ---------------: | --------------: | ------------------------: | -----------: |
| **Geolife Base**        |                          1.092 |            1.508 |           3.032 |                     2.392 |        3.316 |
| **Geolife Expand**      |                          3.033 |            0.267 |           6.045 |                     0.385 |        4.425 |
| **Geolife Shuffle**     |                          0.230 |            0.305 |           8.973 |                     0.463 |        2.572 |
| **Smart meter Base**    |                          1.113 |            1.064 |           3.078 |                    59.734 |       96.977 |
| **Smart meter Expand**  |                          2.475 |            0.211 |           5.510 |                     7.076 |       98.536 |
| **Smart meter Shuffle** |                          0.225 |            0.293 |           9.090 |                    11.796 |       74.999 |

Base スキームでは各ステップごとに GenRand を行うためサーバー負荷が高く，Expand で大幅に軽減，Shuffle ではさらに GenRand フェーズのコストを最小化できている .

**7.4 パラメータ変化の影響**
合成データ上で，乱数長 |𝜌|（32 バイト刻み，最大 1 024 bytes）および Merkle 木深度 dₘₜ（2～11）を変化させた実験を実施した．図 7 の結果から，|𝜌| の増加は証明制約数と Randomize 時間を大きく伸長させるものの，最大でも 8 秒未満に収まり，GenRand 時間はミリ秒オーダーと実用的である．また，dₘₜ の増大は Expand スキームの GenRand 時間を指数的に増加させるが，Randomize は線形増加し，1 024 葉時でも 2 秒程度にとどまる .

---

**8 結論**
本研究では，ローカルモデルおよびシャッフルモデル両者で動作し，入力真正性を保証する検証可能差分プライバシー（VLDP）スキームを提案した．提案手法は，悪意あるクライアントによる入力／出力操作攻撃を防ぎつつ，高いプライバシー増幅効果を維持できる．実験評価により，特に Expand および Shuffle スキームがサーバー負荷を 5–7 ms，クライアント計算時間を 2 秒未満に抑え，かつ広範な LDP アルゴリズムに汎用的に適用可能であることを示した .

以上，VLDP の実装および評価結果を踏まえ，現実的アプリケーションへの適用可能性を示した。
**第4節 DPアルゴリズム**

本節では、文献\[8]にある２種類のローカル差分プライバシ（LDP）アルゴリズムを考察する。ひとつは実数入力 𝑥∈\[0,1] を局所的に乱数応答でランダム化し、集約者が 𝑛 ユーザの入力の総和を算出するものである。もうひとつは整数入力 𝑥∈\[𝑘]（𝑘≥2）を乱数応答によりランダム化し、値のヒストグラムを得るものである。これらのアルゴリズムの擬似コードは図1に示されている。

---

### 実数向けLDPアルゴリズム

入力 𝑥 を \[0,1] に正規化し、精度パラメータ 𝑘∈ℕ を用いてまず

$$
𝑥 \leftarrow \lfloor 𝑥𝑘\rfloor + Ber(𝑥𝑘 - \lfloor 𝑥𝑘\rfloor)
$$

に変換する。これにより出力の取りうる値は {0,1,…,𝑘} となり、デコード後の値の期待値 E(𝑥/𝑘) は元の E(𝑥) と一致する。このメカニズムが ε-DP を満たす条件は

$$
\frac{1 - kγ/(k+1)}{γ/(k+1)} \le e^{\epsilon}
$$

であり、この等式を解くと

$$
γ = \frac{k+1}{e^{\epsilon} + k}
$$

を設定すればよい。また、もし R が (ε,δ)-LDP であれば、メカニズム

$$
M: X^n \to Y^n,\quad M(x_1,\dots,x_n) = (R(x_1),\dots,R(x_n))
$$

も (ε,δ)-DP を満たすことになる。

---

### ヒストグラム向けLDPアルゴリズム

入力 𝑥∈\[𝑘] の場合も γ は上記と同様の式で求めるが、取りうる範囲が {1,…,𝑘} であるため式中の 𝑘 を 𝑘−1 に置き換える必要がある。

---

### 集約器（aggregator）

* ヒストグラムアルゴリズムでは、各カテゴリ 𝑖∈\[𝑘] の出現回数を数えてそのままヒストグラムを出力する。
* 実数アルゴリズムでは、まず出力値をデバイアス（bias を除去）する必要がある。詳細な数式と導出は付録A.1を参照されたい。

**付録 A.1 偏り補正（De-Biased）出力**

ユーザ i が実数入力向け LDP アルゴリズムを実行した後の出力を表す確率変数を 𝑋ᵢ とし，総和を

$$
𝑋 \;=\;\sum_{i=1}^n 𝑋ᵢ
$$

とおく．我々はその期待値

$$
E(𝑋) \;=\;\sum_{i=1}^n E(𝑋ᵢ)
$$

を求めたい．

出力値 j∈{0,1,…,k} を返す確率を p\_j，真の入力値が j である確率を q\_j とすると，LDP メカニズムの乱択規則から

$$
p_j
=\;(1 - γ + \frac{γ}{k+1})\,q_j\;+\;\frac{γ}{k+1}(1 - q_j)
\;=\;(1 - γ)\,q_j\;+\;\frac{γ}{k+1}.
$$

したがってユーザ i の出力の期待値は

$$
\begin{aligned}
E(𝑋ᵢ)
&= \sum_{j=0}^k j\,p_j
= \sum_{j=0}^k j\Bigl((1 - γ)\,q_j + \tfrac{γ}{k+1}\Bigr)\\
&= (1 - γ)\sum_{j=0}^k j\,q_j\;+\;\frac{γ}{k+1}\sum_{j=0}^k j
= (1 - γ)\,μ\;+\;\frac{γ}{k+1}\cdot\frac{k(k+1)}{2}\\
&= (1 - γ)\,μ\;+\;\frac{γ\,k}{2},
\end{aligned}
$$

ただし

$$
μ = \sum_{j=0}^k j\,q_j
$$

は任意ユーザの真の期待入力値である .

全ユーザの合計については

$$
E(𝑋) = n\bigl((1 - γ)\,μ + \tfrac{γ\,k}{2}\bigr)
\;\Longrightarrow\;
\frac{n\,μ}{k}
= \frac{1}{1 - γ}\Bigl(\frac{E(𝑋)}{k} - \frac{γ\,n}{2}\Bigr).
$$

ゆえに，LDP 出力の和を k で割った値 E(𝑋)/k を上式の形で補正すれば，真の入力値の総和 n μ/k を推定できる .

**付録 B シャッフラーの実装**
実用上、信頼できるシャッフラーは複数の方法で実装可能です。代表的なのがミックスネット（mixnet）の利用で、複数のサーバーが順番にメッセージを受け取り、暗号化の「層」を一つずつ剥がしながらランダム順に並べ替えて次へ送信します。最終サーバーは復号された元のメッセージを受け取り、送信元と受信先を切り離します。この方式は元々匿名メールの仕組みとして提案され。

ミックスネット以外にも、

1. **単一の信頼第三者**としてシャッフラーを設置
2. **複数当事者**による分散信頼モデル
3. **信頼ハードウェア**（SGX 等）を用いた実装

といった選択肢があります。本論文のスキームは実装に依存せず、上記いずれの方式にも適用できるよう設計されています .

---

**付録 C セキュリティ証明と実験**

C.1 **実験の定義**
セキュリティ定義（完全性、整合性、ゼロ知識性、シャッフル識別不能性）で用いる実験手順を、図9～図12で形式的に定義しています。各実験は、システムパラメータ生成→鍵生成→攻撃者モデルとのやり取り→プロトコル実行→判定という流れで記述され、特に完全性実験（図9）では正直なクライアントの出力が必ずサーバーに受理されることを検証します .

C.2 **形式的証明**
3つのスキーム（Base, Expand, Shuffle）それぞれについて、完全性・整合性・ゼロ知識性を証明しています。例えばExpandスキームの証明では、

* 完全性はNIZK-PKの完全性に帰着
* 整合性はハイブリッド実験と知識抽出器による議論
* ゼロ知識性はシミュレータ構成とNIZKのゼロ知識性

によって構成されることを示しています .

---

**付録 D 実験詳細と最適化**

D.1 **データセット説明**

* **Geolife GPS Trajectory**: Microsoft Research AsiaのGeoLifeプロジェクトで2007–2012年に収集された182ユーザーのGPS軌跡。地点は郵便番号8カテゴリに集約し、1日5地点を抽出。
* **Smart Meter**: Low Carbon Londonプロジェクト（2011–2014年）の5,567世帯のスマートメーター消費データから、最終5日間の平均消費を正規化して使用。

D.2 **最適化および代替案**
実装で用いた暗号原語やハッシュ関数、署名方式について、以下のような選択肢があります。

* **SNARKフレンドリーなハッシュ**（Poseidon, MiMC, Pedersen など）を使うと、証明生成が最大10倍高速化可能ですが、新規性ゆえのセキュリティリスクもあります。
* **SNARKフレンドリー署名**に置き換える案もありますが、一般性や入手性を優先してEC-Schnorrを採用しました。
* **代替ゼロ知識スキーム**（Marlin, SuperSonic 等）も検討可能ですが、性能トレードオフが存在します。

これらのオプションは必要に応じて差し替え可能で、実装の拡張性を確保しています。




**謝辞**
本研究を改善するために貴重なフィードバックをくださった匿名査読者の皆様に感謝いたします。本研究は、公的、営利、非営利のいずれの資金提供機関からも特定の助成を受けていません .

---

**参考文献**
\[1] Martin Abadi, Andy Chu, Ian Goodfellow, H. Brendan McMahan, Ilya Mironov, Kunal Talwar, and Li Zhang. 2016. *Deep Learning with Differential Privacy*. In Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security (CCS ’16), 308–318.
\[2] Martin Albrecht, Lorenzo Grassi, Christian Rechberger, Arnab Roy, and Tyge Tiessen. 2016. *MiMC: Efficient Encryption and Cryptographic Hashing with Minimal Multiplicative Complexity*. In Advances in Cryptology – ASIACRYPT 2016, 191–219.
…

以降、文献リストは原文の英語表記を維持しています。
