---
marp: true
theme: default
paginate: true
class: lead
---

# シャッフル証明と Bulletproofs R1CS  
手法・脆弱性・実装理由

---

## 1️⃣ シャッフル証明のやり方  

| 役割 | 操作フロー | 使う情報 / 生成物 |
|------|-----------|-------------------|
| **証明者** | 1. コミットし $P(X)=\prod_i(x_i-X)$ 構成<br>2. コミット列をハッシュし乱数 *z* を取得 <br>3. 乗算ゲート鎖で $P(z)$・$Q(z)$ を評価し「差＝0」制約を作成 | 入力リスト $\{x_i\}$、Pedersen基底、ハッシュ関数 |
| **検証者** | 1. コミットを読み取り<br>2. 同じハッシュで **同一の** *z* を再計算<br>3. 同じ制約を再構成し証明を検証 | 公開コミット、ハッシュ関数 |

> **キー**: 乱数 *z* はコミット確定後に決まり、Prover は後出しで値を操作できない

---

### 具体例（体 $\mathbb F_7$、長さ *k = 2*）

1. 入力 $\{2,5\}$，出力 $\{5,2\}$  
2. 多項式  
   $P(X)=(2-X)(5-X)$,  
   $Q(X)=(5-X)(2-X)$
3. ハッシュ→乱数 $z=3$  
4. 評価  
   $P(3)=(-1)\cdot2 \equiv 5$,  
   $Q(3)=2\cdot(-1) \equiv 5$ → 等しい  
   もし出力を $\{5,6\}$ に改変すると  
   $Q'(3)=2\cdot(-1)\cdot3 \equiv 1\neq5$ で失敗

*誤判定確率* ≤ $k/q = 2/7$ （Schwartz–Zippelの補題） 

---

## 2️⃣ 総和・総積テストの脆弱性と理由

### 衝突（すり抜け）例

| テスト | 集合 A | 集合 B | 両者の値 |
|--------|--------|--------|---------|
| 総和   | {1, 4, 5} | {2, 3, 5} | 10 |
| 総積   | {2, 2, 3} | {1, 1, 12} | 12 |

- 総和 $e_1=\sum x_i$、総積 $e_k=\prod x_i$ は **係数の一部** に過ぎず、攻撃者は同じ値になる異集合を容易に作れる 
- よって最悪ケースの誤判定確率＝**100 %**（攻撃者が仕様を知っていれば必ず通過）  
---
### 比較：誤判定確率

| 方法 | 最悪誤判定確率 | 攻撃者の後出し改変 |
|------|---------------|--------------------|
| 総和のみ | 1 | 可能 |
| 総積のみ | 1 | 可能 |
| 乱数 *z* 評価 | $k/q$ | 不可（コミット後に *z* 決定）

---

## 3️⃣ なぜ掛け算チェーン？  
### ― R1CS との親和性
 R1CS 　任意の算術回路を「乗算ゲート＋線形制約」のみで表現する汎用フォーマットについて
1. **R1CS 基本形**  
   $(\mathbf a\cdot\mathbf s)\times(\mathbf b\cdot\mathbf s)= (\mathbf c\cdot\mathbf s)$  
   → “乗算ゲート + 線形制約” のみで表現 
2. **多項式評価と一致**  
   連鎖 $(x_1-z)\to(x_2-z)\to…$ は **各段が 1 乗算ゲート**追加変換不要でそのまま制約化できる 

---

## 補足系


## Rank-1 Constraint System（R1CS）
任意の算術回路を「乗算ゲート＋線形制約」のみで表現する汎用フォーマットについて

---

## 背景
## Bulletproofsを使いたい
## →R1CSを使う※
## →シャッフル証明をするには掛け算がいい
## → $P(X)=\prod_i(x_i-X)$ でのシャッフル証明をする


回路ごとに「信頼できる複数当事者による鍵生成（Trusted Setup）」が必須だったのがいらない
乗算ゲート列を内積引数により一括処理できる
---
<!-- 
## 1. R1CS とは何か

R1CS は「ある解ベクトル $s$」（ワイヤ変数をまとめた ベクトル）が、複数の制約をすべて同時に満たすかを検証する仕組みです
各制約は、ベクトル $\mathbf a,\mathbf b,\mathbf c$ に対して

$$
(\mathbf a \cdot \mathbf s)\;\times\;(\mathbf b \cdot \mathbf s)
\;=\;
(\mathbf c \cdot \mathbf s)
$$

という「一次式の内積を掛け合わせた結果が別の一次式の内積と一致する」形をしています
この「Rank-1」という名称は、係数行列を並べた際にそれぞれの制約が **ランク1 の行列** に対応する点に由来します

---

## 2. 算術回路から R1CS への変換

1. **算術回路の定義**
   算術回路は加算・乗算・定数のゲートで構成され、入力→中間変数→出力へと値を伝播させる構造です
2. **ワイヤ変数の列挙**
   回路上のすべての配線（ワイヤ）は変数 $s_0, s_1, …$ として扱い、解ベクトル $\mathbf s$ にまとめます
3. **乗算ゲート毎の制約化**
   乗算ゲート「$u = v \times w$」は、

   * 係数ベクトル $\mathbf a$ がワイヤ $v$ の係数 1、残り 0
   * $\mathbf b$ がワイヤ $w$ の係数 1、残り 0
   * $\mathbf c$ がワイヤ $u$ の係数 1、残り 0
     として $(\mathbf a\cdot \mathbf s)\times(\mathbf b\cdot \mathbf s) = (\mathbf c\cdot \mathbf s)$ を制約に追加します
4. **加算・定数ゲートの扱い**
   加算 $u = v + w$ は「(ワイヤの線形結合) – 0 = 0」の線形制約一つで表現可能です
5. **全ゲートを集合として保持**
   乗算ゲート×ある数, 線形制約×ある数 が蓄積され、最終的にすべての制約を満たす解ベクトルが正しい証拠となります

---

## 3. R1CS を Bulletproofs で使う意義

Bulletproofs では、R1CS を直接対象とすることで「トラステッドセットアップ不要」「証明が短い」「集約が容易」という特長を享受できます

* **内積引数による圧縮**：複数の乗算ゲートを一度の内積引数でまとめて証明できるため、証明サイズは $O(\log n)$ に縮みます
* **プログラム可能な制約構築**：Rust クレート `bulletproofs::r1cs` の API 上で、Prover／Verifier 双方が同じインターフェースから制約を積み上げられます
* **非対話型化**：Transcript と Fiat–Shamir によるランダムチャレンジを用いることで、対話型のやり取りを完全に排除し、一度のメッセージ交換で証明を完結します

---

## 4. 小さな例で確認

たとえば乗算ゲートが1つだけの回路 $u = v \times w$ を考えます

1. **変数**：ワイヤ $v, w, u$ を $\mathbf s=(v, w, u)$ に配置
2. **制約**：

   $$
     (1\cdot v + 0\cdot w + 0\cdot u)\;\times\;(0\cdot v + 1\cdot w + 0\cdot u)\;=\;(0\cdot v + 0\cdot w + 1\cdot u).
   $$
3. **R1CS 形式**：
   $\mathbf a=(1,0,0),\;\mathbf b=(0,1,0),\;\mathbf c=(0,0,1)$ を用いて制約を記述します
   この一つの制約だけで「$u$ が $v\times w$ である」関係を完全に示せることが分かります
---

### まとめ

* **R1CS** は「乗算ゲート×線形結合」を繰り返すだけで任意の算術回路を表現可能なフォーマットです
* **算術回路→R1CS** 変換時には、ゲート毎に対応するベクトル $(\mathbf a,\mathbf b,\mathbf c)$ を生成し、解ベクトル $\mathbf s$ が全制約を満たすかをチェックします
* **Bulletproofs** は R1CS をそのまま短いゼロ知識証明に組み込み、セットアップフリーで効率的な証明システムを実現しています
 -->
